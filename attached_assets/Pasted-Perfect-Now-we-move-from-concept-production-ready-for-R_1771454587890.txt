Perfect. Now we move from concept â†’ **production-ready for Replit**.

Since you're likely building CulturePass as:

* Frontend: React / Next.js
* Backend: Node.js (Express or Hono)
* Database: Firestore or PostgreSQL
* Hosting: Replit Deployments

Iâ€™ll fine-tune the **Role + Entity + Approval system** specifically for Replit architecture.

---

# ğŸ§± Recommended Replit Architecture

## Option A (Best for Scale)

Frontend â†’ Next.js (App Router)
Backend â†’ Express API (separate folder)
Database â†’ PostgreSQL (via Replit DB or Neon)
Auth â†’ Firebase Auth or Clerk
Payments â†’ Stripe Connect

## Option B (Simpler MVP)

Frontend + Backend in one Next.js app
API routes inside `/app/api`
Firestore for DB
Stripe

For CulturePass scale â†’ I recommend Option A.

---

# ğŸ“ Replit Folder Structure (Clean & Scalable)

```
/culturepass
â”‚
â”œâ”€â”€ /client              (Next.js frontend)
â”‚   â”œâ”€â”€ /app
â”‚   â”œâ”€â”€ /components
â”‚   â”œâ”€â”€ /features
â”‚   â”‚   â”œâ”€â”€ entities
â”‚   â”‚   â”œâ”€â”€ events
â”‚   â”‚   â”œâ”€â”€ tickets
â”‚   â”‚   â”œâ”€â”€ dashboard
â”‚   â”‚   â”œâ”€â”€ sponsors
â”‚   â”‚   â””â”€â”€ services
â”‚   â”œâ”€â”€ /lib
â”‚   â””â”€â”€ /hooks
â”‚
â”œâ”€â”€ /server              (Express backend)
â”‚   â”œâ”€â”€ /routes
â”‚   â”‚   â”œâ”€â”€ auth.routes.ts
â”‚   â”‚   â”œâ”€â”€ entity.routes.ts
â”‚   â”‚   â”œâ”€â”€ event.routes.ts
â”‚   â”‚   â”œâ”€â”€ ticket.routes.ts
â”‚   â”‚   â”œâ”€â”€ sponsor.routes.ts
â”‚   â”‚   â””â”€â”€ admin.routes.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ /middleware
â”‚   â”‚   â”œâ”€â”€ auth.middleware.ts
â”‚   â”‚   â”œâ”€â”€ role.middleware.ts
â”‚   â”‚   â””â”€â”€ entity.middleware.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ /services
â”‚   â”‚   â”œâ”€â”€ stripe.service.ts
â”‚   â”‚   â”œâ”€â”€ ticket.service.ts
â”‚   â”‚   â”œâ”€â”€ entity.service.ts
â”‚   â”‚   â””â”€â”€ approval.service.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ /models
â”‚   â””â”€â”€ server.ts
â”‚
â””â”€â”€ shared
    â”œâ”€â”€ types.ts
    â””â”€â”€ constants.ts
```

This keeps things modular and production-safe.

---

# ğŸ§© Entity Role System (Replit-Ready)

Instead of Firestore rules, we enforce logic at API layer.

## entity_roles table (PostgreSQL Example)

```sql
CREATE TABLE entity_roles (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  entity_id UUID NOT NULL,
  user_id UUID NOT NULL,
  role VARCHAR(50) NOT NULL,
  created_at TIMESTAMP DEFAULT NOW()
);
```

Roles allowed:

* owner
* admin
* event_manager
* finance_manager
* content_editor

---

# ğŸ” Middleware for Permission (Replit Express Example)

### auth.middleware.ts

```ts
export const requireAuth = (req, res, next) => {
  if (!req.user) {
    return res.status(401).json({ message: "Unauthorized" });
  }
  next();
};
```

---

### role.middleware.ts

```ts
export const requireEntityRole = (allowedRoles: string[]) => {
  return async (req, res, next) => {
    const { entityId } = req.params;
    const userId = req.user.id;

    const role = await getUserRole(entityId, userId);

    if (!role || !allowedRoles.includes(role)) {
      return res.status(403).json({ message: "Forbidden" });
    }

    next();
  };
};
```

---

### Example: Create Event Route

```ts
router.post(
  "/:entityId/events",
  requireAuth,
  requireEntityRole(["owner", "admin", "event_manager"]),
  createEventController
);
```

Clean. Scalable. No frontend hacks.

---

# ğŸ— Entity Approval Workflow (Backend Logic)

## entity table

```sql
status VARCHAR(20) DEFAULT 'pending'
```

Possible values:

* pending
* approved
* rejected
* suspended

---

### Only SuperAdmin Can Approve

```ts
router.patch(
  "/admin/entities/:id/approve",
  requireAuth,
  requirePlatformRole(["superadmin"]),
  approveEntityController
);
```

---

### Approval Controller

```ts
if (entity.status !== "pending") {
  return res.status(400).json({ message: "Invalid state" });
}

entity.status = "approved";
entity.events_enabled = true;
```

---

# ğŸŸ Ticket Engine (Replit Stripe Connect Safe Setup)

## Stripe Flow

1. Entity connects Stripe
2. Stripe returns account_id
3. Save in entities table
4. Tickets cannot go live without stripe_account_id

---

### Ticket Creation Validation

```ts
if (!entity.stripe_account_id) {
  return res.status(400).json({
    message: "Connect Stripe before selling tickets"
  });
}
```

---

# ğŸ“… Calendar Sync (Server Side)

Generate .ics dynamically:

Route:

```
GET /events/:id/calendar.ics
```

Response:

* content-type: text/calendar
* dynamic event details

Replit handles this easily.

---

# ğŸ Perks Table

```sql
CREATE TABLE perks (
  id UUID PRIMARY KEY,
  entity_id UUID,
  title TEXT,
  description TEXT,
  visibility VARCHAR(50),
  created_by UUID
);
```

Visibility values:

* public
* members_only
* paid_members
* event_attendees

Access enforced in API layer.

---

# ğŸ§  SuperAdmin Structure (Replit Production Safe)

Add platform_roles table:

```sql
CREATE TABLE platform_roles (
  user_id UUID PRIMARY KEY,
  role VARCHAR(50)
);
```

Only:

* superadmin
* moderator

Never store superadmin flag on frontend.

Always validate server-side.

---

# ğŸ”¥ Replit-Specific Hardening Tips

1. Use `.env` secrets in Replit Secrets Manager
2. Never expose Stripe secret keys
3. Add rate limiting middleware
4. Enable CORS restrictions
5. Log audit actions in database
6. Use UUIDs everywhere
7. Use server-side pagination

---

# ğŸš€ Deployment Model on Replit

Replit Deployments:

* Autoscale
* Set health check route `/health`
* Use environment variables
* Connect to Neon/Postgres external DB

---

# ğŸ§  Final Strategic Advice for Replit

Do NOT:

* Put business logic in frontend
* Rely on client-side role checks
* Skip financial audit logs
* Hardcode roles

DO:

* Enforce every permission at API layer
* Log every financial change
* Separate platform role & entity role
* Keep Stripe webhook on backend only

---

Bibinâ€¦ if we architect this cleanly on Replit:

Youâ€™ll have a production-grade SaaS foundation.

Now choose next refinement:

A) Full PostgreSQL schema (complete tables + relationships)
B) Stripe Connect revenue split logic design
C) SuperAdmin analytics dashboard architecture
D) Full system architecture diagram (infra level)

Weâ€™re building properly now. ğŸ”¥
